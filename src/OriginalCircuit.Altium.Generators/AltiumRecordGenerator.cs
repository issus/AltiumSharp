using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace OriginalCircuit.Altium.Generators;

/// <summary>
/// Source generator that creates FromParameters() and ToParameters() methods
/// for classes marked with [AltiumRecord].
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AltiumRecordGenerator : IIncrementalGenerator
{
    private const string AltiumRecordAttributeName = "OriginalCircuit.Altium.Generators.AltiumRecordAttribute";
    private const string AltiumParameterAttributeName = "OriginalCircuit.Altium.Generators.AltiumParameterAttribute";
    private const string AltiumCoordAttributeName = "OriginalCircuit.Altium.Generators.AltiumCoordAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attributes and helper classes for consuming projects
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                "AltiumAttributes.g.cs",
                SourceText.From(GenerateAttributes(), Encoding.UTF8));
            ctx.AddSource(
                "ParameterCollection.g.cs",
                SourceText.From(GenerateParameterCollection(), Encoding.UTF8));
        });

        // Find all types with [AltiumRecord]
        var typeDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AltiumRecordAttributeName,
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (ctx, ct) => GetTypeToGenerate(ctx, ct))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!.Value);

        // Generate source for each type
        context.RegisterSourceOutput(typeDeclarations, static (spc, typeInfo) =>
        {
            var source = GenerateSource(typeInfo);
            var fileName = typeInfo.FullyQualifiedName
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_")
                .Replace(",", "_")
                .Replace(" ", "");
            spc.AddSource($"{fileName}.AltiumSerialization.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static string GenerateAttributes()
    {
        return @"// <auto-generated/>
#nullable enable

namespace OriginalCircuit.Altium.Generators
{
    /// <summary>
    /// Marks a property as an Altium parameter to be serialized/deserialized.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Property)]
    public sealed class AltiumParameterAttribute : global::System.Attribute
    {
        /// <summary>
        /// The parameter name in the Altium file format.
        /// </summary>
        public string Name { get; }

        /// <summary>
        /// Minimum Altium version where this parameter exists.
        /// </summary>
        public string? MinVersion { get; set; }

        /// <summary>
        /// Maximum Altium version where this parameter exists.
        /// </summary>
        public string? MaxVersion { get; set; }

        public AltiumParameterAttribute(string name)
        {
            Name = name;
        }
    }

    /// <summary>
    /// Marks a record type as an Altium record for source generation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
    public sealed class AltiumRecordAttribute : global::System.Attribute
    {
        /// <summary>
        /// The record type name in the Altium file format.
        /// </summary>
        public string RecordType { get; }

        public AltiumRecordAttribute(string recordType)
        {
            RecordType = recordType;
        }
    }

    /// <summary>
    /// Indicates that the property represents a coordinate value.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Property)]
    public sealed class AltiumCoordAttribute : global::System.Attribute
    {
    }
}
";
    }

    private static string GenerateParameterCollection()
    {
        return @"// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using OriginalCircuit.Eda.Primitives;

namespace OriginalCircuit.Altium.Primitives
{
    /// <summary>
    /// A simple parameter collection for building Altium parameter strings.
    /// Generated by AltiumRecordGenerator.
    /// </summary>
    public sealed class ParameterCollection
    {
        private readonly List<KeyValuePair<string, string>> _parameters = new List<KeyValuePair<string, string>>();

        /// <summary>
        /// The separator character used between parameters.
        /// </summary>
        public char Separator { get; set; } = '|';

        /// <summary>
        /// Whether to use long boolean format (TRUE/FALSE vs T/F).
        /// </summary>
        public bool UseLongBooleans { get; set; }

        /// <summary>
        /// Gets the number of parameters.
        /// </summary>
        public int Count
        {
            get { return _parameters.Count; }
        }

        /// <summary>
        /// Gets a parameter value by key.
        /// </summary>
        public ParameterValue this[string key]
        {
            get
            {
                for (int i = 0; i < _parameters.Count; i++)
                {
                    if (string.Equals(_parameters[i].Key, key, StringComparison.OrdinalIgnoreCase))
                    {
                        return new ParameterValue(_parameters[i].Value);
                    }
                }
                return new ParameterValue(null);
            }
        }

        /// <summary>
        /// Adds a string parameter.
        /// </summary>
        public void Add(string key, string? value, bool ignoreDefaultValue = true)
        {
            if (ignoreDefaultValue && string.IsNullOrEmpty(value))
                return;
            _parameters.Add(new KeyValuePair<string, string>(key, value ?? """"));
        }

        /// <summary>
        /// Adds an integer parameter.
        /// </summary>
        public void Add(string key, int value, bool ignoreDefaultValue = true)
        {
            if (ignoreDefaultValue && value == 0)
                return;
            _parameters.Add(new KeyValuePair<string, string>(key, value.ToString(CultureInfo.InvariantCulture)));
        }

        /// <summary>
        /// Adds a long parameter.
        /// </summary>
        public void Add(string key, long value, bool ignoreDefaultValue = true)
        {
            if (ignoreDefaultValue && value == 0)
                return;
            _parameters.Add(new KeyValuePair<string, string>(key, value.ToString(CultureInfo.InvariantCulture)));
        }

        /// <summary>
        /// Adds a double parameter.
        /// </summary>
        public void Add(string key, double value, bool ignoreDefaultValue = true, int decimals = 6)
        {
            if (ignoreDefaultValue && value == 0.0)
                return;
            var format = ""0."" + new string('0', decimals);
            _parameters.Add(new KeyValuePair<string, string>(key, value.ToString(format, CultureInfo.InvariantCulture).TrimEnd('0').TrimEnd('.')));
        }

        /// <summary>
        /// Adds a boolean parameter.
        /// </summary>
        public void Add(string key, bool value, bool ignoreDefaultValue = true)
        {
            if (ignoreDefaultValue && !value)
                return;
            var trueVal = UseLongBooleans ? ""TRUE"" : ""T"";
            var falseVal = UseLongBooleans ? ""FALSE"" : ""F"";
            _parameters.Add(new KeyValuePair<string, string>(key, value ? trueVal : falseVal));
        }

        /// <summary>
        /// Adds a coordinate parameter (stored as mils).
        /// </summary>
        public void Add(string key, Coord value, bool ignoreDefaultValue = true)
        {
            if (ignoreDefaultValue && value == Coord.Zero)
                return;
            _parameters.Add(new KeyValuePair<string, string>(key, value.ToString(""mil"", CultureInfo.InvariantCulture)));
        }

        /// <summary>
        /// Adds an enum parameter (stored as integer).
        /// </summary>
        public void AddEnum<T>(string key, T value, bool ignoreDefaultValue = true) where T : struct
        {
            var intVal = Convert.ToInt32(value, CultureInfo.InvariantCulture);
            if (ignoreDefaultValue && intVal == 0)
                return;
            _parameters.Add(new KeyValuePair<string, string>(key, intVal.ToString(CultureInfo.InvariantCulture)));
        }

        /// <summary>
        /// Converts the collection to an Altium parameter string.
        /// </summary>
        public override string ToString()
        {
            var sb = new StringBuilder();
            foreach (var kvp in _parameters)
            {
                sb.Append(Separator);
                sb.Append(kvp.Key);
                sb.Append('=');
                sb.Append(kvp.Value);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Clears all parameters.
        /// </summary>
        public void Clear()
        {
            _parameters.Clear();
        }

        /// <summary>
        /// Parses a parameter string into a collection.
        /// </summary>
        public static ParameterCollection Parse(string data)
        {
            var result = new ParameterCollection();
            if (string.IsNullOrEmpty(data))
                return result;

            var entries = data.Split(new[] { '|' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (var entry in entries)
            {
                var equalsIndex = entry.IndexOf('=');
                if (equalsIndex > 0)
                {
                    var key = entry.Substring(0, equalsIndex);
                    var value = equalsIndex < entry.Length - 1 ? entry.Substring(equalsIndex + 1) : """";

                    // Handle UTF-8 prefix
                    if (key.StartsWith(""%UTF8%"", StringComparison.OrdinalIgnoreCase))
                    {
                        key = key.Substring(6);
                    }

                    result._parameters.Add(new KeyValuePair<string, string>(key, value.TrimEnd('\r', '\n')));
                }
            }
            return result;
        }
    }

    /// <summary>
    /// Represents a parameter value with type conversion methods.
    /// </summary>
    public readonly struct ParameterValue
    {
        private readonly string? _value;

        public ParameterValue(string? value)
        {
            _value = value;
        }

        public string? AsStringOrDefault(string? defaultValue = null)
        {
            return _value ?? defaultValue;
        }

        public int AsIntOrDefault(int defaultValue = 0)
        {
            if (_value == null)
                return defaultValue;
            if (int.TryParse(_value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result))
                return result;
            return defaultValue;
        }

        public double AsDoubleOrDefault(double defaultValue = 0.0)
        {
            if (_value == null)
                return defaultValue;
            if (double.TryParse(_value, NumberStyles.Any, CultureInfo.InvariantCulture, out var result))
                return result;
            return defaultValue;
        }

        public bool AsBool()
        {
            if (string.IsNullOrEmpty(_value))
                return false;
            if (_value.Length == 1)
                return _value[0] == 'T' || _value[0] == 't';
            return string.Equals(_value, ""TRUE"", StringComparison.OrdinalIgnoreCase);
        }

        public Coord AsCoord()
        {
            if (_value == null)
                return Coord.Zero;
            if (Coord.TryParse(_value.AsSpan(), out var result))
                return result;
            return Coord.Zero;
        }

        public T AsEnumOrDefault<T>(T defaultValue = default) where T : struct
        {
            if (_value == null)
                return defaultValue;
            if (int.TryParse(_value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var intVal))
                return (T)Enum.ToObject(typeof(T), intVal);
            return defaultValue;
        }
    }
}
";
    }

    private static TypeToGenerate? GetTypeToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
            return null;

        ct.ThrowIfCancellationRequested();

        // Get the record type from the attribute
        var recordAttribute = context.Attributes.FirstOrDefault(a =>
            a.AttributeClass?.ToDisplayString() == AltiumRecordAttributeName);

        if (recordAttribute is null)
            return null;

        var recordType = recordAttribute.ConstructorArguments.Length > 0
            ? recordAttribute.ConstructorArguments[0].Value?.ToString() ?? ""
            : "";

        // Determine the type kind
        var isRecord = context.TargetNode is RecordDeclarationSyntax;
        var isStruct = typeSymbol.IsValueType;
        var isSealed = typeSymbol.IsSealed;

        // Gather properties with [AltiumParameter]
        var properties = new List<PropertyToGenerate>();

        foreach (var member in typeSymbol.GetMembers())
        {
            ct.ThrowIfCancellationRequested();

            if (member is not IPropertySymbol property)
                continue;

            if (property.IsStatic || property.IsIndexer)
                continue;

            var paramAttribute = property.GetAttributes().FirstOrDefault(a =>
                a.AttributeClass?.ToDisplayString() == AltiumParameterAttributeName);

            if (paramAttribute is null)
                continue;

            var parameterName = paramAttribute.ConstructorArguments.Length > 0
                ? paramAttribute.ConstructorArguments[0].Value?.ToString() ?? property.Name.ToUpperInvariant()
                : property.Name.ToUpperInvariant();

            string? minVersion = null;
            string? maxVersion = null;

            foreach (var namedArg in paramAttribute.NamedArguments)
            {
                if (namedArg.Key == "MinVersion" && namedArg.Value.Value is string min)
                    minVersion = min;
                else if (namedArg.Key == "MaxVersion" && namedArg.Value.Value is string max)
                    maxVersion = max;
            }

            var isCoord = property.GetAttributes().Any(a =>
                a.AttributeClass?.ToDisplayString() == AltiumCoordAttributeName);

            var propertyType = GetPropertyTypeKind(property.Type, isCoord);

            // Determine if property has a setter (regular or init)
            var hasSetter = property.SetMethod != null;
            var hasInitSetter = property.SetMethod?.IsInitOnly == true;
            var isReadOnly = !hasSetter;

            // Get the underlying type for nullable types
            var typeNameForGeneration = GetTypeNameForGeneration(property.Type);

            properties.Add(new PropertyToGenerate(
                property.Name,
                parameterName,
                typeNameForGeneration,
                propertyType,
                isCoord,
                isReadOnly,
                hasInitSetter,
                minVersion,
                maxVersion,
                IsNullableType(property.Type)));
        }

        var containingNamespace = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : typeSymbol.ContainingNamespace.ToDisplayString();

        return new TypeToGenerate(
            typeSymbol.Name,
            containingNamespace,
            typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            recordType,
            properties.ToImmutableArray(),
            isStruct,
            isRecord,
            isSealed);
    }

    private static string GetTypeNameForGeneration(ITypeSymbol type)
    {
        // Handle nullable value types
        if (type is INamedTypeSymbol { IsGenericType: true } namedType &&
            namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
        {
            return namedType.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        return type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    private static bool IsNullableType(ITypeSymbol type)
    {
        // Reference types with nullable annotation
        if (type.NullableAnnotation == NullableAnnotation.Annotated)
            return true;

        // Nullable<T>
        if (type is INamedTypeSymbol { IsGenericType: true } namedType &&
            namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
            return true;

        // Reference types without nullable annotation: only treat as nullable
        // if the nullable context is not enabled (annotation is None, not NotAnnotated)
        if (!type.IsValueType && type.NullableAnnotation == NullableAnnotation.None)
            return true;

        return false;
    }

    private static PropertyTypeKind GetPropertyTypeKind(ITypeSymbol type, bool isCoordAttribute)
    {
        // Handle nullable value types
        if (type is INamedTypeSymbol { IsGenericType: true } namedType &&
            namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
        {
            type = namedType.TypeArguments[0];
        }

        // Check for actual Coord type (not just [AltiumCoord] attribute)
        var typeName = type.ToDisplayString();
        if (typeName.EndsWith("Coord", StringComparison.Ordinal) ||
            typeName == "OriginalCircuit.Eda.Primitives.Coord" ||
            typeName == "global::OriginalCircuit.Eda.Primitives.Coord")
            return PropertyTypeKind.Coord;

        // Use actual property type for serialization
        // The [AltiumCoord] attribute is metadata only - it doesn't change how we serialize
        return type.SpecialType switch
        {
            SpecialType.System_String => PropertyTypeKind.String,
            SpecialType.System_Int32 => PropertyTypeKind.Int,
            SpecialType.System_Int64 => PropertyTypeKind.Long,
            SpecialType.System_Double => PropertyTypeKind.Double,
            SpecialType.System_Single => PropertyTypeKind.Float,
            SpecialType.System_Boolean => PropertyTypeKind.Bool,
            SpecialType.System_Byte => PropertyTypeKind.Byte,
            SpecialType.System_Int16 => PropertyTypeKind.Short,
            _ => type.TypeKind == TypeKind.Enum ? PropertyTypeKind.Enum : PropertyTypeKind.Unknown
        };
    }

    private static string GenerateSource(TypeToGenerate typeInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine("using global::OriginalCircuit.Eda.Primitives;");
        sb.AppendLine("using global::OriginalCircuit.Altium.Primitives;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(typeInfo.Namespace))
        {
            sb.AppendLine($"namespace {typeInfo.Namespace}");
            sb.AppendLine("{");
        }

        var indent = string.IsNullOrEmpty(typeInfo.Namespace) ? "" : "    ";

        // Determine keyword based on type
        string typeKeyword;
        if (typeInfo.IsRecord && typeInfo.IsStruct)
            typeKeyword = "record struct";
        else if (typeInfo.IsRecord)
            typeKeyword = "record";
        else if (typeInfo.IsStruct)
            typeKeyword = "struct";
        else
            typeKeyword = "class";

        sb.AppendLine($"{indent}partial {typeKeyword} {typeInfo.Name}");
        sb.AppendLine($"{indent}{{");

        // Generate static factory method for parsing (works with records)
        GenerateFromParametersStaticMethod(sb, typeInfo, indent);

        sb.AppendLine();

        // Generate instance method for parsing (for mutable types)
        var hasSettableProperties = typeInfo.Properties.Any(p => !p.HasInitSetter && !p.IsReadOnly);
        if (!typeInfo.IsRecord || hasSettableProperties)
        {
            GenerateFromParametersInstanceMethod(sb, typeInfo, indent);
            sb.AppendLine();
        }

        // Generate ToParameters method
        GenerateToParametersMethod(sb, typeInfo, indent);

        sb.AppendLine($"{indent}}}");

        if (!string.IsNullOrEmpty(typeInfo.Namespace))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void GenerateFromParametersStaticMethod(StringBuilder sb, TypeToGenerate typeInfo, string indent)
    {
        var methodIndent = indent + "    ";
        var bodyIndent = methodIndent + "    ";

        sb.AppendLine($"{methodIndent}/// <summary>");
        sb.AppendLine($"{methodIndent}/// Creates a new instance from a parameter collection.");
        sb.AppendLine($"{methodIndent}/// </summary>");
        sb.AppendLine($"{methodIndent}/// <param name=\"parameters\">The parameter collection to read from.</param>");
        sb.AppendLine($"{methodIndent}/// <param name=\"version\">Optional Altium version for version-specific parameters.</param>");
        sb.AppendLine($"{methodIndent}/// <returns>A new instance populated from the parameters.</returns>");
        sb.AppendLine($"{methodIndent}public static {typeInfo.Name} FromParameters(global::OriginalCircuit.Altium.Primitives.ParameterCollection parameters, string? version = null)");
        sb.AppendLine($"{methodIndent}{{");
        sb.AppendLine($"{bodyIndent}if (parameters == null) throw new global::System.ArgumentNullException(nameof(parameters));");
        sb.AppendLine();

        // Declare local variables for each property
        foreach (var prop in typeInfo.Properties)
        {
            if (prop.IsReadOnly)
                continue;

            var defaultValue = GetDefaultValue(prop);
            sb.AppendLine($"{bodyIndent}var _{ToCamelCase(prop.Name)} = {defaultValue};");
        }

        sb.AppendLine();

        // Parse each property
        foreach (var prop in typeInfo.Properties)
        {
            if (prop.IsReadOnly)
                continue;

            var versionCheck = GenerateVersionCheck(prop, bodyIndent);
            if (!string.IsNullOrEmpty(versionCheck))
            {
                sb.AppendLine(versionCheck);
                sb.AppendLine($"{bodyIndent}{{");
                GenerateFromParameterAssignment(sb, prop, bodyIndent + "    ", $"_{ToCamelCase(prop.Name)}");
                sb.AppendLine($"{bodyIndent}}}");
            }
            else
            {
                GenerateFromParameterAssignment(sb, prop, bodyIndent, $"_{ToCamelCase(prop.Name)}");
            }
        }

        sb.AppendLine();

        // Create and return the instance
        if (typeInfo.IsRecord)
        {
            sb.AppendLine($"{bodyIndent}return new {typeInfo.Name}");
            sb.AppendLine($"{bodyIndent}{{");
            var propList = typeInfo.Properties.Where(p => !p.IsReadOnly).ToList();
            for (var i = 0; i < propList.Count; i++)
            {
                var prop = propList[i];
                var comma = i < propList.Count - 1 ? "," : "";
                sb.AppendLine($"{bodyIndent}    {prop.Name} = _{ToCamelCase(prop.Name)}{comma}");
            }
            sb.AppendLine($"{bodyIndent}}};");
        }
        else
        {
            sb.AppendLine($"{bodyIndent}var result = new {typeInfo.Name}();");
            foreach (var prop in typeInfo.Properties)
            {
                if (prop.IsReadOnly)
                    continue;
                sb.AppendLine($"{bodyIndent}result.{prop.Name} = _{ToCamelCase(prop.Name)};");
            }
            sb.AppendLine($"{bodyIndent}return result;");
        }

        sb.AppendLine($"{methodIndent}}}");

        // Also generate overload that takes a string
        sb.AppendLine();
        sb.AppendLine($"{methodIndent}/// <summary>");
        sb.AppendLine($"{methodIndent}/// Creates a new instance from a parameter string.");
        sb.AppendLine($"{methodIndent}/// </summary>");
        sb.AppendLine($"{methodIndent}/// <param name=\"parameterData\">The parameter string to parse.</param>");
        sb.AppendLine($"{methodIndent}/// <param name=\"version\">Optional Altium version for version-specific parameters.</param>");
        sb.AppendLine($"{methodIndent}/// <returns>A new instance populated from the parameters.</returns>");
        sb.AppendLine($"{methodIndent}public static {typeInfo.Name} FromParameters(string parameterData, string? version = null)");
        sb.AppendLine($"{methodIndent}{{");
        sb.AppendLine($"{bodyIndent}var parameters = global::OriginalCircuit.Altium.Primitives.ParameterCollection.Parse(parameterData);");
        sb.AppendLine($"{bodyIndent}return FromParameters(parameters, version);");
        sb.AppendLine($"{methodIndent}}}");
    }

    private static void GenerateFromParametersInstanceMethod(StringBuilder sb, TypeToGenerate typeInfo, string indent)
    {
        var methodIndent = indent + "    ";
        var bodyIndent = methodIndent + "    ";

        sb.AppendLine($"{methodIndent}/// <summary>");
        sb.AppendLine($"{methodIndent}/// Populates this instance from a parameter collection.");
        sb.AppendLine($"{methodIndent}/// </summary>");
        sb.AppendLine($"{methodIndent}/// <param name=\"parameters\">The parameter collection to read from.</param>");
        sb.AppendLine($"{methodIndent}/// <param name=\"version\">Optional Altium version for version-specific parameters.</param>");
        sb.AppendLine($"{methodIndent}public void ReadFromParameters(global::OriginalCircuit.Altium.Primitives.ParameterCollection parameters, string? version = null)");
        sb.AppendLine($"{methodIndent}{{");
        sb.AppendLine($"{bodyIndent}if (parameters == null) throw new global::System.ArgumentNullException(nameof(parameters));");
        sb.AppendLine();

        foreach (var prop in typeInfo.Properties)
        {
            // Skip properties that can't be set (read-only or init-only)
            if (prop.IsReadOnly || prop.HasInitSetter)
                continue;

            var versionCheck = GenerateVersionCheck(prop, bodyIndent);
            if (!string.IsNullOrEmpty(versionCheck))
            {
                sb.AppendLine(versionCheck);
                sb.AppendLine($"{bodyIndent}{{");
                GenerateFromParameterAssignment(sb, prop, bodyIndent + "    ", $"this.{prop.Name}");
                sb.AppendLine($"{bodyIndent}}}");
            }
            else
            {
                GenerateFromParameterAssignment(sb, prop, bodyIndent, $"this.{prop.Name}");
            }
        }

        sb.AppendLine($"{methodIndent}}}");
    }

    private static void GenerateFromParameterAssignment(StringBuilder sb, PropertyToGenerate prop, string indent, string target)
    {
        var paramAccess = $"parameters[\"{prop.ParameterName}\"]";

        string assignment;
        switch (prop.TypeKind)
        {
            case PropertyTypeKind.String:
                assignment = prop.IsNullable
                    ? $"{target} = {paramAccess}.AsStringOrDefault();"
                    : $"{target} = {paramAccess}.AsStringOrDefault() ?? string.Empty;";
                break;

            case PropertyTypeKind.Int:
                assignment = $"{target} = {paramAccess}.AsIntOrDefault();";
                break;

            case PropertyTypeKind.Long:
                assignment = $"{target} = (long){paramAccess}.AsIntOrDefault();";
                break;

            case PropertyTypeKind.Short:
                assignment = $"{target} = (short){paramAccess}.AsIntOrDefault();";
                break;

            case PropertyTypeKind.Byte:
                assignment = $"{target} = (byte){paramAccess}.AsIntOrDefault();";
                break;

            case PropertyTypeKind.Double:
                assignment = $"{target} = {paramAccess}.AsDoubleOrDefault();";
                break;

            case PropertyTypeKind.Float:
                assignment = $"{target} = (float){paramAccess}.AsDoubleOrDefault();";
                break;

            case PropertyTypeKind.Bool:
                assignment = $"{target} = {paramAccess}.AsBool();";
                break;

            case PropertyTypeKind.Coord:
                assignment = $"{target} = {paramAccess}.AsCoord();";
                break;

            case PropertyTypeKind.Enum:
                assignment = $"{target} = {paramAccess}.AsEnumOrDefault<{prop.TypeName}>();";
                break;

            default:
                assignment = $"// TODO: Unsupported type for property {prop.Name}: {prop.TypeName}";
                break;
        }

        sb.AppendLine($"{indent}{assignment}");
    }

    private static string GetDefaultValue(PropertyToGenerate prop)
    {
        switch (prop.TypeKind)
        {
            case PropertyTypeKind.String:
                // For nullable strings, we need an explicit cast to satisfy var inference
                return prop.IsNullable ? "(string?)null" : "string.Empty";
            case PropertyTypeKind.Int:
                return "0";
            case PropertyTypeKind.Long:
                return "0L";
            case PropertyTypeKind.Short:
                return "(short)0";
            case PropertyTypeKind.Byte:
                return "(byte)0";
            case PropertyTypeKind.Double:
                return "0.0";
            case PropertyTypeKind.Float:
                return "0.0f";
            case PropertyTypeKind.Bool:
                return "false";
            case PropertyTypeKind.Coord:
                return "global::OriginalCircuit.Eda.Primitives.Coord.Zero";
            case PropertyTypeKind.Enum:
                return $"default({prop.TypeName})";
            default:
                return "default";
        }
    }

    private static void GenerateToParametersMethod(StringBuilder sb, TypeToGenerate typeInfo, string indent)
    {
        var methodIndent = indent + "    ";
        var bodyIndent = methodIndent + "    ";

        sb.AppendLine($"{methodIndent}/// <summary>");
        sb.AppendLine($"{methodIndent}/// Exports this instance to a parameter collection.");
        sb.AppendLine($"{methodIndent}/// </summary>");
        sb.AppendLine($"{methodIndent}/// <param name=\"parameters\">The parameter collection to write to.</param>");
        sb.AppendLine($"{methodIndent}/// <param name=\"version\">Optional Altium version for version-specific parameters.</param>");
        sb.AppendLine($"{methodIndent}public void ToParameters(global::OriginalCircuit.Altium.Primitives.ParameterCollection parameters, string? version = null)");
        sb.AppendLine($"{methodIndent}{{");
        sb.AppendLine($"{bodyIndent}if (parameters == null) throw new global::System.ArgumentNullException(nameof(parameters));");
        sb.AppendLine();

        foreach (var prop in typeInfo.Properties)
        {
            var versionCheck = GenerateVersionCheck(prop, bodyIndent);
            if (!string.IsNullOrEmpty(versionCheck))
            {
                sb.AppendLine(versionCheck);
                sb.AppendLine($"{bodyIndent}{{");
                GenerateToParameterAssignment(sb, prop, bodyIndent + "    ");
                sb.AppendLine($"{bodyIndent}}}");
            }
            else
            {
                GenerateToParameterAssignment(sb, prop, bodyIndent);
            }
        }

        sb.AppendLine($"{methodIndent}}}");

        // Also generate overload that creates and returns a new ParameterCollection
        sb.AppendLine();
        sb.AppendLine($"{methodIndent}/// <summary>");
        sb.AppendLine($"{methodIndent}/// Exports this instance to a new parameter collection.");
        sb.AppendLine($"{methodIndent}/// </summary>");
        sb.AppendLine($"{methodIndent}/// <param name=\"version\">Optional Altium version for version-specific parameters.</param>");
        sb.AppendLine($"{methodIndent}/// <returns>A new parameter collection containing this instance's values.</returns>");
        sb.AppendLine($"{methodIndent}public global::OriginalCircuit.Altium.Primitives.ParameterCollection ToParameters(string? version = null)");
        sb.AppendLine($"{methodIndent}{{");
        sb.AppendLine($"{bodyIndent}var parameters = new global::OriginalCircuit.Altium.Primitives.ParameterCollection();");
        sb.AppendLine($"{bodyIndent}ToParameters(parameters, version);");
        sb.AppendLine($"{bodyIndent}return parameters;");
        sb.AppendLine($"{methodIndent}}}");
    }

    private static void GenerateToParameterAssignment(StringBuilder sb, PropertyToGenerate prop, string indent)
    {
        string assignment;
        switch (prop.TypeKind)
        {
            case PropertyTypeKind.String:
                assignment = prop.IsNullable
                    ? $"if ({prop.Name} != null) parameters.Add(\"{prop.ParameterName}\", {prop.Name});"
                    : $"parameters.Add(\"{prop.ParameterName}\", {prop.Name});";
                break;

            case PropertyTypeKind.Int:
            case PropertyTypeKind.Short:
            case PropertyTypeKind.Byte:
                assignment = $"parameters.Add(\"{prop.ParameterName}\", (int){prop.Name});";
                break;

            case PropertyTypeKind.Long:
                assignment = $"parameters.Add(\"{prop.ParameterName}\", {prop.Name});";
                break;

            case PropertyTypeKind.Double:
            case PropertyTypeKind.Float:
                assignment = $"parameters.Add(\"{prop.ParameterName}\", (double){prop.Name});";
                break;

            case PropertyTypeKind.Bool:
                assignment = $"parameters.Add(\"{prop.ParameterName}\", {prop.Name});";
                break;

            case PropertyTypeKind.Coord:
                assignment = $"parameters.Add(\"{prop.ParameterName}\", {prop.Name});";
                break;

            case PropertyTypeKind.Enum:
                assignment = $"parameters.AddEnum(\"{prop.ParameterName}\", {prop.Name});";
                break;

            default:
                assignment = $"// TODO: Unsupported type for property {prop.Name}: {prop.TypeName}";
                break;
        }

        sb.AppendLine($"{indent}{assignment}");
    }

    private static string GenerateVersionCheck(PropertyToGenerate prop, string indent)
    {
        if (prop.MinVersion == null && prop.MaxVersion == null)
            return "";

        var conditions = new List<string>();

        if (prop.MinVersion != null)
        {
            conditions.Add($"CompareVersions(version, \"{prop.MinVersion}\") >= 0");
        }

        if (prop.MaxVersion != null)
        {
            conditions.Add($"CompareVersions(version, \"{prop.MaxVersion}\") <= 0");
        }

        var condition = string.Join(" && ", conditions);
        return $"{indent}if (version != null && {condition})";
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;
        if (name.Length == 1)
            return name.ToLowerInvariant();
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private readonly struct TypeToGenerate
    {
        public string Name { get; }
        public string Namespace { get; }
        public string FullyQualifiedName { get; }
        public string RecordType { get; }
        public ImmutableArray<PropertyToGenerate> Properties { get; }
        public bool IsStruct { get; }
        public bool IsRecord { get; }
        public bool IsSealed { get; }

        public TypeToGenerate(
            string name,
            string ns,
            string fullyQualifiedName,
            string recordType,
            ImmutableArray<PropertyToGenerate> properties,
            bool isStruct,
            bool isRecord,
            bool isSealed)
        {
            Name = name;
            Namespace = ns;
            FullyQualifiedName = fullyQualifiedName;
            RecordType = recordType;
            Properties = properties;
            IsStruct = isStruct;
            IsRecord = isRecord;
            IsSealed = isSealed;
        }
    }

    private readonly struct PropertyToGenerate
    {
        public string Name { get; }
        public string ParameterName { get; }
        public string TypeName { get; }
        public PropertyTypeKind TypeKind { get; }
        public bool IsCoord { get; }
        public bool IsReadOnly { get; }
        public bool HasInitSetter { get; }
        public string? MinVersion { get; }
        public string? MaxVersion { get; }
        public bool IsNullable { get; }

        public PropertyToGenerate(
            string name,
            string parameterName,
            string typeName,
            PropertyTypeKind typeKind,
            bool isCoord,
            bool isReadOnly,
            bool hasInitSetter,
            string? minVersion,
            string? maxVersion,
            bool isNullable)
        {
            Name = name;
            ParameterName = parameterName;
            TypeName = typeName;
            TypeKind = typeKind;
            IsCoord = isCoord;
            IsReadOnly = isReadOnly;
            HasInitSetter = hasInitSetter;
            MinVersion = minVersion;
            MaxVersion = maxVersion;
            IsNullable = isNullable;
        }
    }

    private enum PropertyTypeKind
    {
        Unknown,
        String,
        Int,
        Long,
        Short,
        Byte,
        Double,
        Float,
        Bool,
        Coord,
        Enum
    }
}
