using OriginalCircuit.Altium.Diagnostics;
using OriginalCircuit.Altium.Serialization.Writers;

namespace OriginalCircuit.Altium.Models.Pcb;

/// <summary>
/// Implementation of a PCB footprint library.
/// </summary>
public sealed class PcbLibrary : IPcbLibrary
{
    private readonly List<IPcbComponent> _components = new();
    private readonly Dictionary<string, IPcbComponent> _componentsByName = new(StringComparer.OrdinalIgnoreCase);
    private IReadOnlyList<IComponent>? _allComponentsCache;

    /// <summary>
    /// Diagnostics collected during file reading (warnings about skipped records, parse errors, etc.).
    /// </summary>
    public IReadOnlyList<AltiumDiagnostic> Diagnostics { get; internal set; } = Array.Empty<AltiumDiagnostic>();

    /// <summary>
    /// Section keys mapping component names to their OLE storage section key strings.
    /// Needed when component names exceed 31 chars or contain special characters.
    /// </summary>
    internal Dictionary<string, string>? SectionKeys { get; set; }

    /// <summary>
    /// Library-level parameters from the Library/Data stream.
    /// Contains the full set of PCB library metadata (layer stacks, design rules, etc.).
    /// When null, defaults (HEADER + WEIGHT) are used for new files.
    /// </summary>
    internal Dictionary<string, string>? LibraryParameters { get; set; }

    /// <summary>
    /// Unique identifier for this library (8-character random string).
    /// Generated by Altium when the library is created.
    /// </summary>
    public string UniqueId { get; set; } = GenerateUniqueId();

    /// <summary>
    /// 3D models embedded in this library. Each model contains STEP data
    /// and metadata referenced by <see cref="PcbComponentBody.ModelId"/>.
    /// </summary>
    public List<PcbModel> Models { get; } = new();

    /// <summary>
    /// Additional OLE streams within the Library storage, preserved for round-trip fidelity.
    /// Known streams: "ComponentParamsTOC" (table of contents for component parameters),
    /// "EmbeddedFonts" (font data), "PadViaLibrary" (pad/via templates).
    /// Key format: "StreamName" or "SubStorageName/StreamName" -> byte data.
    /// Empty by default for from-scratch creation (these streams are optional).
    /// </summary>
    public Dictionary<string, byte[]>? AdditionalLibraryStreams { get; set; }

    /// <summary>
    /// Additional root-level OLE storages with their streams, preserved for round-trip fidelity.
    /// Known storages: "FileVersionInfo" (file format version metadata).
    /// Key format: "StorageName/StreamName" -> byte data.
    /// Empty by default for from-scratch creation (these streams are optional).
    /// </summary>
    public Dictionary<string, byte[]>? AdditionalRootStreams { get; set; }

    /// <inheritdoc />
    public IReadOnlyList<IPcbComponent> Components => _components;

    /// <inheritdoc />
    public IReadOnlyList<IComponent> AllComponents =>
        _allComponentsCache ??= _components.Cast<IComponent>().ToList();

    /// <inheritdoc />
    public int Count => _components.Count;

    /// <inheritdoc />
    public IPcbComponent? this[string name] =>
        _componentsByName.TryGetValue(name, out var component) ? component : null;

    /// <inheritdoc />
    public bool Contains(string name) => _componentsByName.ContainsKey(name);

    /// <inheritdoc />
    public void Add(IPcbComponent component)
    {
        ArgumentNullException.ThrowIfNull(component);

        if (string.IsNullOrEmpty(component.Name))
            throw new ArgumentException("Component must have a name", nameof(component));

        if (_componentsByName.ContainsKey(component.Name))
            throw new ArgumentException($"A component named '{component.Name}' already exists", nameof(component));

        _components.Add(component);
        _componentsByName[component.Name] = component;
        _allComponentsCache = null; // Invalidate cache
    }

    /// <inheritdoc />
    public bool Remove(string name)
    {
        if (!_componentsByName.TryGetValue(name, out var component))
            return false;

        _components.Remove(component);
        _componentsByName.Remove(name);
        _allComponentsCache = null; // Invalidate cache
        return true;
    }

    /// <inheritdoc />
    public async ValueTask SaveAsync(string path, SaveOptions? options = null, CancellationToken cancellationToken = default)
    {
        options ??= new SaveOptions();

        var mode = options.Overwrite ? FileMode.Create : FileMode.CreateNew;
        await using var stream = new FileStream(path, mode, FileAccess.Write, FileShare.None, 4096, useAsync: true);
        await SaveAsync(stream, options, cancellationToken);
    }

    /// <inheritdoc />
    public async ValueTask SaveAsync(Stream stream, SaveOptions? options = null, CancellationToken cancellationToken = default)
    {
        var writer = new PcbLibWriter();
        await writer.WriteAsync(this, stream, cancellationToken);
    }

    /// <inheritdoc />
    public ValueTask DisposeAsync()
    {
        // No unmanaged resources to dispose
        return ValueTask.CompletedTask;
    }

    private static string GenerateUniqueId()
    {
        const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var random = Random.Shared;
        return string.Create(8, random, (span, rng) =>
        {
            for (var i = 0; i < span.Length; i++)
                span[i] = chars[rng.Next(chars.Length)];
        });
    }
}
